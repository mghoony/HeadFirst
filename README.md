# HeadFirst 디자인패턴 개정판

## 디자인 원칙
1. 바뀌는 부분을 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.
2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
3. 상속보다는 구성을 활용한다.
4. 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야 한다.
5. 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.
6. 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다. (Dependency Inversion Principle)

## Chapter 1
오리 장난감 코드를 사용해서 전략 패턴을 설명

### 전략 패턴
전략 패턴(Strategy Pattern)은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해 줍니다.   
전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.

## Chapter 2
기후 스테이션, 디스플레이를 사용해서 옵저버 패턴을 설명

### 옵저버 패턴
옵저버 패턴(Observer Pattern)은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다.   
보통은 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인으로 구현합니다.

### 느슨한 결합의 위력
1. 옵저버는 언제든지 새로 추가할 수 있습니다.
2. 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 전혀 없습니다.
3. 주제와 옵저버는 서로 독립적으로 재사용할 수 있습니다.
4. 주제나 옵저버가 달라져도 서로에게 영향을 미치지 않습니다.

## Chapter 3
스타버즈 커피 사례를 사용해서 데코레이터 패턴을 설명

### 데코레이터 패턴
데코레이터 패턴(Decorator Pattern)으로 객체에 추가 요소를 동적으로 더할 수 있습니다.
데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다.
* 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같습니다.
* 한 객체를 여러 개의 데코레이터로 감쌀 수 있습니다.
* 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체(싸여 있는 객체)가 들어갈 자리에 
데코레이터 객체를 넣어도 상관 없습니다.
* 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있습니다.
* 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있습니다.

## Chapter 4
피자 가게 사례를 사용해서 팩토리 메소드 패턴을 설명

### 팩토리 메소드 패턴
간단한 팩토리(Simple Factory)는 팩토리 패턴은 아니다.
팩토리 메소드 패턴(Factory Method Pattern)에서는 객체를 생성할 때 필요한 인터페이스를 만듭니다.
어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정합니다. 팩토리 메소드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 됩니다.
* 생산자와 제품으로 구성
* 생산자는 실제 생산될 제품을 전혀 모르고 구상 클래스에서 제품이 결정됨.

### 의존성 뒤집기 원칙을 지키는 방법
* 변수에 구상 클래스의 레퍼런스를 저장하지 않는다.
* 구상 클래스에서 유도된 클래스를 만들지 않는다.
* 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드 하지 않는다.

### 추상 팩토리 패턴
추상 팩토리 패턴(Abstract Factory Pattern)은 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공합니다.
구상 클래스는 서브클래스에서 만듭니다.    
일련의 연관 제품을 하나로(제품군) 묶을 수 있는 장점이 있다.

팩토리 메소드 패턴은 상속으로 객체를 만들고 추상 팩토리 패턴은 구성으로 만든다.

## Chapter 5
싱글턴 패턴

### 싱글턴 패턴
싱글턴 패턴(Singleton Pattern)은 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공합니다.

### Volatile
* 변수의 읽기/쓰기 명령을 메인 메모리로부터 수행하여 가시성을 보장한다. 
* 두 쓰레드가 해당 변수에 읽기/쓰기를 실행할 때는 원자성을 보장하지 할 수 없다.
* 메인 메모리로부터 데이터를 읽고 쓰는 작업은 CPU 캐시를 이용하는 것 보다 많은 비용이 필요하다.
